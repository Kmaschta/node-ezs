#!/usr/bin/env node
const fs = require('fs');
const ezs = require('../lib');
const { version } = require('../package.json');
const yargs = require('yargs')
    .env('EZS')
    .usage('Usage: $0 [options] [<file>]')
    .version(version)
    .options({
        verbose: {
            alias: 'v',
            default: false,
            describe: 'Print some informations',
            type: 'boolean',
        },
        daemon: {
            alias: 'd',
            default: false,
            describe: 'Launch daemon',
            type: 'boolean',
        },
        server: {
            alias: 's',
            describe: 'Server to dispach commands',
            type: 'string',
        },
        port: {
            alias: 'p',
            describe: 'Change daemon\'port',
            default: 31976,
            type: 'number',
        },
    })
    .epilogue('for more information, find our manual at https://github.com/touv/node-ezs');

const argv = yargs.argv;
const firstarg = argv._.shift();

if (argv.daemon) {
    ezs.createCluster();
}


if (!argv.daemon && !firstarg) {
    yargs.showHelp();
    process.exit(1);
}


if (firstarg) {
    let file;
    try {
        file = fs.realpathSync(firstarg);
    } catch (e) {
        console.error(`${firstarg} doesn't exists.`);
        yargs.showHelp();
        process.exit(1);
    }

    if (!fs.statSync(file).isFile()) {
        console.error(`${firstarg} isn't a file.`);
        yargs.showHelp();
        process.exit(1);
    }

    const script = fs.readFileSync(file).toString();
    const commands = ezs.parseString(script);

    if (argv.verbose) {
        console.error('Reading standard input...');
    }

    process.stdin.resume();
    process.stdin.setEncoding('utf8');

    const servers = Array.isArray(argv.server) ? argv.server : [argv.server];
    const statement = argv.server ? ezs.dispatch(commands, servers) : ezs.pipeline(commands);
    const stream1 = process.stdin.pipe(statement);
    const stream2 = stream1.pipe(ezs.toBuffer());
    stream2.on('end', () => {
        process.exit(1);
    });
    stream2.pipe(process.stdout);
}
